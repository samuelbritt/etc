" Modeline and Notes {
" vim: set foldmarker={,} foldlevel=0 foldmethod=marker ts=4 sw=4 spell:
" }

" Environment {
	set nocompatible 				" must be first line

	" Pathogen Support {
		runtime! bundle/pathogen/autoload/pathogen.vim
		silent! call pathogen#runtime_append_all_bundles()
		silent! call pathogen#helptags()
	" }

 	filetype plugin indent on		" detect filetypes
	syntax on						" syntax highlighting
	set mouse=a 					" enable the mouse
	set dir=~/.swp					" don't litter project with ~ files
	set history=50					" keep 50 lines of command line history
	set viminfo+='100,f1 			" history between sessions
	set hidden 						" allow switching buffers without saving

	" restores normal vim keybindings for macvim
	if has("gui_macvim")
		let macvim_skip_cmd_opt_movement = 1
	endif

	" When editing a file, always jump to the last known cursor position.
	" Don't do it when the position is invalid or when inside an event handler
	" (happens when dropping a file on gvim).
	autocmd BufReadPost *
			\ if line("'\"") > 0 && line("'\"") <= line("$") |
			\   exe "normal! g`\"" |
			\ endif
" }

" Vim UI {
	source $VIMRUNTIME/macros/matchit.vim 			" enable % matching
	let &sbr = nr2char(8618).' ' 	" show arrow at beginning of wrapped lines
	set backspace=indent,eol,start 	" backspace over everything
	set whichwrap+=<,>,[,]			" changing lines with arrow keys
	set ruler						" show the cursor position all the time
	set showcmd						" display incomplete commands
	set incsearch					" do incremental searching
	set hlsearch					" highlight search
	set wildmenu					" tab completion on commands
	set wildignore=*.o,*.a,*.so,*.swp,*.aux,*.pdf	" hide from completion
	set wildmode=longest:full,list:full 			" bash compatible behavior
	set completeopt=menuone,longest,preview			" insert completion
	set winaltkeys=no				" turns off Alt for menu navigation
	set ignorecase					" ingnore case in searches
	set smartcase					" don't ignore case with uppercase in pattern
	set nostartofline 				" keeps cursor in same spot when scrolling
	set showmatch 					" highlight matching braces
	set matchtime=1                 " showmatch is annoying
	set title 						" better titles in terminals
	set scrolloff=3 				" keep some context when scrolling
	set linebreak                   " wrap lines sanely
	set foldcolumn=1				" click to fold
	set gdefault					" global subst. by default; use '/g' to revert
	set tags+=tags;/				" search for tags in higher directories
	set switchbuf+=usetab			" switch to open buffer first, rather than
									" 	duplicating file in current buffer
	" Statusline {
		set laststatus=2						" always show statusline
		set statusline=%f\    			    	" filename
		set statusline+=%w%h%m%r                " flags
		set statusline+=\ %Y                    " filetype
		set statusline+=\ [%<%{getcwd()}]\      " current dir
		set statusline+=%=%-11.(%l,%c%V%)\ %p%% " file nav info
	" }

	" Highlight trailing whitespace
	au BufEnter * match TODO /\s\+$/
	au InsertEnter * match TODO /\s\+\%#\@<!$/
	au InsertLeave * match TODO /\s\+$/
" }

" Formatting {
	" Colors {
		if has("gui_running")
			" see .gvimrc
		else
			colorscheme peaksea
			set t_Co=256			" number of colors in terminal
			set bg=dark  			" must come after colorscheme
		endif
	" }
	set autoindent					" always set autoindenting on
" }

" Maps And Commands {

	" Reset leader to something easier to type
	let mapleader = ","

	" more logical behavior of Y
	nnoremap Y y$

	" alternate escape
	inoremap jj <ESC>

	" make the . command return to the point where the command started
	noremap . .`[

	" Push line down, up in command mode (can delete lines)
	nnoremap + maO<esc>`a
	nnoremap _ makdd`a

	" Move line(s) up or down (swaps with adjacent lines
	nnoremap <M-=> mz:m+<CR>`z
	nnoremap <M--> mz:m-2<CR>`z
	vnoremap <M-=> :m'>+<CR>`<my`>mzgv`yo`z
	vnoremap <M--> :m'<-2<CR>`>my`<mzgv`yo`z

	" put current word on commandline
	cmap <F2> <C-R><C-W>

	" Write buffer through sudo
	cnoreabbrev w!! w !sudo tee % >/dev/null

	" ` is more useful but less accessible than '
	nnoremap ' `
	nnoremap ` '

	" unhighlight after search
	nmap <silent> <leader><space> :silent :nohlsearch<CR>

	" move by screen line, not file line
	nnoremap j gj
	nnoremap k gk

	" Filename, line, and tag completion
	inoremap <C-F> <C-X><C-F>
	inoremap <C-L> <C-X><C-L>
	inoremap <C-]> <C-X><C-]>

	" Command to change to the directory of the current window (LCD) and all
	" windows (GCD)
	command! CD lcd %:p:h
	command! LCD lcd %:p:h
	command! GCD cd %:p:h

	" visual shifting (does not exit Visual mode)
	vnoremap < <gv
	vnoremap > >gv

	" build tags files in insert or normal mode
	noremap <F11> :!ctags -R --c-kinds=+p --fields=+S .<CR>
	noremap <F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<CR>
	inoremap <F12> <ESC>:!ctags -R --c++-kinds=+p --c-kinds=+p --fields=+iaS --extra=+q .<CR>

	" Command to see the difference between the current buffer and the file it
	" was loaded from, thus the changes you made.
	command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
			\ | wincmd p | diffthis

	" Function to trim trailing white spaces
	function! <SID>TrimTrailingSpaces()
		let l = line(".")
		let c = col(".")
		%s/\s\+$//e
		call cursor(l, c)
	endfunction
	command! TrimTrailingSpaces :call <SID>TrimTrailingSpaces()
" }

" Plugins {
	" Vim-LaTeX {
		" IMPORTANT: grep will sometimes skip displaying the file name if you
		" search in a singe file. This will confuse latex-suite. Set your grep
		" program to always generate a file-name.
		set grepprg=grep\ -nH\ $*
		let g:tex_flavor='latex' 			" Sets .tex to be LaTeX file type
		let g:Tex_ViewRule_pdf='open'
	" }

	" NERDComments {
		let NERDCommentWholeLinesInVMode=1
		let NERDSpaceDelims=1
 	" }

	" NERDTree {
		let NERDTreeIgnore=['\.o$']
		let NERDTreeChDirMode=2 		" change dir when changing root
		let NERDTreeShowBookmarks=1
	" }

	" OmniCpp {
		set tags+=~/.vim/tags/cpp		" STL
		" let OmniCpp_ShowPrototypeInAbbr = 1
		" let OmniCpp_SelectFirstItem = 2 " select without inserting, ignored when
						  " completeopt contains 'longest'
		" automatically open and close the popup menu / preview window
		" au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
	" }

	" SuperTab {
		let g:SuperTabDefaultCompletionType = 'context'
		let g:SuperTabMappingForward = '<C-Space>'
		let g:SuperTabMappingBackward = '<S-C-Space>'
		let g:SuperTabCrMapping = 0
		let g:SuperTabLongestEnhanced = 1
		let g:SuperTabLongestHighlight = 1
	" }

	" SnipMate {
		let g:snips_author = 'Sam Britt <samuelbritt@gmail.com>'
		let g:snippets_dir = $HOME . '/.vim/custom-snippets'
	" }

	" DelimitMate {
		let delimitMate_balance_matchpairs = 1
		let delimitMate_expand_space = 1
		let delimitMate_expand_cr = 1
	" }

	" Taglist {
		map <F2> :TlistToggle<CR>
	" }

	" TaskList {
		map <leader>l <Plug>TaskList
	" }

	" Gundo {
		nnoremap <F4> :GundoToggle<CR>
		let g:gundo_close_on_revert=1
	" }
" }
